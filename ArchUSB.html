<!DOCTYPE html>
<!--<======================  arch-usb.html  =======================>--->
<!-- Guide to installing Arch Linux on a USB stick.  Honestly, I use
this guide every time I install Arch now.  I wrote it a while back
(years now) and maintain it more for myself than anything else. -->

<html lang="en">
<head>
    <title>ArchLinux USB</title>
    <meta http-equiv="content-type" content="text/html;charset=utf-8">
    <meta name="viewport"
        content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Guide to installing Arch Linux on
        a USB stick.">
    <meta name="keywords" content="Linux, Arch Linux, USB, install,
        persistent">
    <meta name="author" content="Chris Magyar">
    <link rel="stylesheet" href="css/dark-blue.css">
</head>
<body>

<div class="heading">
<div class="align-right float-right">
<br>
2021-01-04<br>
----------<br>
c-magyar
</div>
<pre class="w-140 w-120">   _____                 __     ___     __                      ___ ___  ________ _______
  /  _  \  _____   ____ |  |__ |   |   |__| ____  __ ____  ___ |   |   \/   ____/|  __   \
 /  /_\  \|  __ \_/ ___\|     \|   |    __ /    \|  |  \ \/  / |   |    \____  \ |      _/
/   ___   \  | \/\  \___|   \  \   |___|  |   |  \  |  /    \  |   |    /       \|   __  \
\__/   \__/__|    \____/|___|__/_______\__|___|__/____/__/\__\  \______/\_______/|_______/
</pre>
<pre class="w-100">    _             _     _     _                    _   _ ____  ____
   / \   _ __ ___| |__ | |   (_)_ __  _   ___  __ | | | / ___|| __ )
  / _ \ | '__/ __| '_ \| |   | | '_ \| | | \ \/ / | | | \___ \|  _ \
 / ___ \| | | (__| | | | |___| | | | | |_| |>  <  | |_| |___) | |_) |
/_/   \_\_|  \___|_| |_|_____|_|_| |_|\__,_/_/\_\  \___/|____/|____/
</pre>
<pre class="w-80">   _          _    _    _                _   _ ___ ___
  /_\  _ _ __| |_ | |  (_)_ _ _  ___ __ | | | / __| _ )
 / _ \| '_/ _| ' \| |__| | ' \ || \ \ / | |_| \__ \ _ \
/_/ \_\_| \__|_||_|____|_|_||_\_,_/_\_\  \___/|___/___/
</pre>
<pre class="w-60">   _          _      _   _ ___ ___
  /_\  _ _ __| |_   | | | / __| _ )
 / _ \| '_/ _| ' \  | |_| \__ \ _ \
/_/ \_\_| \__|_||_|  \___/|___/___/
</pre>
</div>
<br>

<pre class="float-right heading">
+-------------------+
| <a href="#why" target="_self">Why Arch Linux</a>    |
|   <a href="#about" target="_self">about guide</a>     |
| <a href="#before" target="_self">Before You Begin</a>  |
|   <a href="#live_img" target="_self">live image</a>      |
|   <a href="#wired_wifi" target="_self">wired vs wifi</a>   |
|   <a href="#bios_uefi" target="_self">BIOS vs UEFI</a>    |
|   <a href="#secure_boot" target="_self">secure boot</a>     |
|   <a href="#localtime_utc" target="_self">localtime/UTC</a>   |
|   <a href="#partitioning" target="_self">partitioning</a>    |
| <a href="#boot_live" target="_self" >Boot Live ISO</a>     |
|   <a href="#keys_language" target="_self">keys/language</a>   |
| <a href="#connect" target="_self" >Internet</a>          |
|   <a href="#wired" target="_self">wired</a>           |
|   <a href="#wireless" target="_self">wireless</a>        |
|   <a href="#live_time" target="_self">system time</a>     |
| <a href="#prepare" target="_self">Prepare USB</a>       |
|   <a href="#wipe" target="_self">wipe</a>            |
|   <a href="#partition" target="_self">partition</a>       |
|   <a href="#format" target="_self">format</a>          |
| <a href="#base" target="_self">Base System</a>       |
|   <a href="#mount" target="_self">mount</a>           |
|   <a href="#pacstrap" target="_self">pacstrap</a>        |
|   <a href="#fstab" target="_self">fstab</a>           |
| <a href="#configure" target="_self">Configure System</a>  |
|   <a href="#chroot" target="_self">chroot</a>          |
|   <a href="#locale" target="_self">locale</a>          |
|   <a href="#hostname" target="_self">hostname</a>        |
|   <a href="#RAM_disk" target="_self">initramfs</a>       |
|   <a href="#interface_names" target="_self">interface names</a> |
|   <a href="#journal_config" target="_self">journal</a>         |
|   <a href="#mount_options" target="_self">mount options</a>   |
|   <a href="#bootloader" target="_self">bootloader</a>      |
|   <a href="#networking" target="_self">networking</a>      |
|   <a href="#video" target="_self">video drivers</a>   |
|   <a href="#touchpad" target="_self">touchpad</a>        |
|   <a href="#battery" target="_self">battery</a>         |
|   <a href="#root" target="_self">password</a>        |
|   <a href="#user" target="_self">sudo</a>            |
|   <a href="#logout" target="_self">logout</a>          |
+-------------------+
</pre>

This page explains how to install Arch Linux on a USB key (flash
drive).  The end result will be a persistent installation identical
to that on a normal hard drive with the goal of maximum compatibility
with any machine the flash drive is boot on.<br>
<br>

<h1 id="before">
This information is found in other locations:<br>
=============================================</h1>
<p>
  <a href="https://magyar.urown.cloud/arch-usb.html">https://magyar.urown.cloud/arch-usb.html</a>
  <br>
  <a href="http://archive.is/7FFiQ">http://archive.is/7FFiQ</a>
</p>
<br>
<h1 id="why">
Why Arch Linux?<br>
===============</h1>

There are already several guides to setting up a persistent
Linux installation on a USB drive out there, including a dedicated
<a href="https://wiki.archlinux.org/" target="_blank">ArchWiki</a>
<a href="https://wiki.archlinux.org/index.php/Installing_Arch_Linux_on_a_USB_key" target="_blank">page</a>.
In theory, an installation on a USB key should be no different than
any other installation, and perhaps some GUI installers out there
will work just fine.  However I've heard of several failed attempts
at getting a USB Linux installation working properly when working
from said installers or guides.  I have a few ideas on why this
might be occurring and have attempted to correct these scenarios
with this process.  Arch Linux serves this purpose well due to its
ability to easily change  configuration options to the user's need.<br>
<br>

<h2 id="about">
about this guide<br>
----------------</h2>

Perhaps the biggest reason for the existence of this entire
guide is my own curiosity. You may find the nature of an Arch Linux
installation provides more insight into what is happening behind the
scenes than any GUI installation tool out there.  Messing around with
Linux like this can be fun (and frustrating!).  I find learning how my
computer works and finely tuning its configuration to be rewarding.
With an Arch Linux persistent bootable USB I have my own completely
custom operating system, application set, and user interface with me
in my pocket everywhere I go!<br>
<br>

Also, I suppose I should say, I am in no way officially associated
with Linux or the Arch Linux project.  I am simply a curious tinkerer
who uses the act writing things like this as a learning experience.
I have personally followed these steps over a dozen times on
multiple computers with no problems, but I can't guarantee it will
work for you.  I wrote this guide to be (hopefully) followable by
anyone with a moderate understanding of current PCs.  My intention is
for this to be a fully self contained guide, yet numerous links are
provided throughout the text to supporting references and additional
resources.<br>
<br>

<h1 id="before">
Before You Begin<br>
================</h1>

To begin this installation you will need a USB flash drive to
install on, of course.  Although a typical Arch Linux installation
with a fully functional desktop environment usually ranges
from about 3GB to 5GB, I recommend using at least a 16GB stick.
Being that this is an entirely portable Linux system of your own,
you may want to load it up with a collection of some great GNU and
open source software packages out there.  With some large packages
like <a href="http://www.sagemath.org/" target="_blank">SageMath</a>,
<a href="https://www.tug.org/texlive/" target="_blank">TeX Live</a>,
and various developer tools, my current Arch Linux USB drive sits at
around 12GB.<br>
<br>

<h2 id="live_img">
live image<br>
----------</h2>

You will also need to <a href="https://www.archlinux.org/download/"
target="_blank">download</a> an Arch Linux bootable installation ISO
and either burn it to a CD or write it to a different USB stick than
the one you will be installing your persistent copy on.  I have used
both methods with no problems, but the speed of installation is much
greater when using a bootable USB stick.<br>
<br>

To write a bootable USB installation medium in Linux, run the
following command; <i>/path/archlinux.iso</i>
is the path to the downloaded ISO and
<i>/dev/sdX</i> is the path to your unmounted
target USB drive:<br>
<pre class="code-box w-140 w-120 w-100 w-80">
+-----------------------------------------------------------------------+
|# <b>dd bs=4M if=<i>/path/archlinux.iso</i> of=<i>/dev/sdX</i> status=progress &amp;&amp; sync</b>  |
+-----------------------------------------------------------------------+
</pre>
<pre class="code-box w-60">
+-----------------------------------------------+
|# <b>dd bs=4M if=<i>/path/archlinux.iso</i> of=<i>/dev/sdX</i></b>  |
|:     <b>status=progress && sync</b>                  |
+-----------------------------------------------+
</pre>
<br>

To make a bootable USB using Windows, I have used the
open source GUI tool <a href="https://rufus.akeo.ie/"
target="_blank">Rufus</a> on several occasions without any
issues.  If Rufus doesn't work for you, there are multiple other <a
href="http://www.makeuseof.com/tag/10-tools-make-bootable-usb-iso-file/"
target="_blank">programs</a> intended for the same thing.<br>
<br>

Users with a current working installation of Arch Linux can opt to
forgo a new boot medium altogether and simply partition, format, <em>pacstrap</em>, and <em>arch-chroot</em>
into the target USB drive instead.  The instructions to do so are
not explicitly provided here as that is not the scope of this guide,
but the important parts of the process are identical.<br>
<br>

<h2 id="wired_wifi">
wired vs wifi<br>
-------------</h2>

For the actual installation you will need a computer connected
to the internet.  A wired connection is definitely preferred as the
bootable installation ISO is setup to automatically detect and connect
to any wired network on bootup.  Also, any packages you choose to
install will need to be downloaded from the Arch Linux repositories,
and network speed may be a limiting factor over wifi.<br>
<br>

The instructions in this guide will setup your persistent bootable
USB to automatically configure a wired network connection whenever
a network cable is detected.  Support for most wifi interfaces will
also be installed, but automatic connection will not be enabled.
Having automatic wifi connection capability is quite simple to setup,
but for this bootable Linux USB it won't be enabled by default as
not every machine it is boot on will even have a wifi interface.<br>
<br>

Lastly, Linux kind of has a horrible history of working with
some wifi interfaces.  There is a chance, albeit rare, that you
may be the proud owner of a wifi networking device not compatible
with Linux... yet (until you write the driver for it!).  For more
information pertaining to Linux wireless interface compatibility,
see the official <a href="https://wireless.wiki.kernel.org/"
target="_blank">wireless wiki</a>.<br>
<br>

<h2 id="bios_uefi">
BIOS vs UEFI<br>
------------</h2>

Basically, there are two different systems implemented
today that motherboards use to communicate between an operating
system and their firmware.  There is the standard (legacy) <a
href="https://en.wikipedia.org/wiki/BIOS" target="_blank">BIOS</a>
(basic input/output system), and there is the newer <a
href="https://wiki.archlinux.org/index.php/Unified_Extensible_Firmware_Interface"
target="_blank">UEFI</a> (unified extensible firmware interface).
Although UEFI was implemented on some top-end machines in the early
2000s, any computer more than six or seven years old is probably only
going to be able to boot up in BIOS mode.  Newer machines, on the other
hand, will often be capable of booting in both UEFI mode and BIOS mode.
Many times a preferred boot mode can be selected from the BIOS menu
on such machines.  Current Apple computers only recognize UEFI.<br>
<br>

Both BIOS and UEFI require different particular partition schemes
in order to boot.  If the motherboard is set to boot in UEFI mode
only and the inserted boot media does not have the correct partition
scheme for UEFI, the boot will fail; the same goes for an attempted
BIOS boot.  This is one place I believe some of the USB installation
guides out there fail: they often only describe how to create a
USB boot device that uses only one mode.  It is possible, however,
to setup a USB drive that will have a partition scheme allowing it
to boot in both modes and still use the same persistent installation
of Linux.  This guide will setup such a scheme in the partitioning
and formatting sections below.<br>
<br>

On most newer machines, you will be presented with the option to
boot in either BIOS or UEFI mode from your bootable USB.  This means
the machine recognizes the UEFI boot media, but it does not always
mean the machine is actually set to boot in UEFI mode, and selecting
the UEFI boot option may fail.  Selecting a mode that the motherboard
is not set to boot in will not damage anything or touch any of the
other drives on the machine, the boot will simply fail and one can
reboot in the other mode.  The USB stick created with this guide
has been able to boot on every (about a dozen) desktop and laptop,
new and old, BIOS and UEFI, machine that I have tried it on.<br>
<br>

<h2 id="secure_boot">
secure boot<br>
-----------</h2>

The new UEFI specification also includes an optional
mechanism to protect against pre-boot malware.  The <a
href="http://www.rodsbooks.com/efi-bootloaders/secureboot.html"
target="_blank">secure boot</a> protocol is designed
to only allow the booting of images signed with a <a
href="https://en.wikipedia.org/wiki/Key_(cryptography)"
target="_blank">cryptographic key</a> contained in a machine's <a
href="https://en.wikipedia.org/wiki/Non-volatile_random-access_memory"
target="_blank">NVRAM</a>.  If secure boot is enabled and a boot image
lacks a cryptographic signature or the signature doesn't correspond
to a key listed in the computer's NVRAM, the firmware will refuse
to execute the boot image.  The most common workaround when dealing
with secure boot on Linux machines is to simply disable the secure
boot option in the machine's BIOS menu.<br>
<br>

If it is not possible to disable secure boot in a machine's BIOS or
you wish to use secure boot on your Arch Linux USB, you will need to
install a <a href="https://aur.archlinux.org/packages/shim-signed/"
target="_blank">signed bootloader</a> and properly <a
href="https://wiki.archlinux.org/index.php/Secure_Boot#Set_up_shim"
target="_blank">set it up</a> after this guide.<br>
<br>

<h2 id="localtime_utc">
localtime vs UTC<br>
----------------</h2>

There are two time standards used by the internal hardware
clock of a modern computer to store the current time.
Localtime is dependent on the machine's current geographical
time zone and often takes daylight savings into account, while <a
href="https://en.wikipedia.org/wiki/Coordinated_Universal_Time"
target="_blank">UTC</a> (coordinated universal time) is the same
regardless of global location.  The hardware clock stores the current
time, in one of these two formats, by storing separate values for
<em>year, month, day, hour, minute</em>, and <em>second</em>.<br>
<br>

The hardware clock does not, however, retain any record of what
format its time values are kept in or if there has been any adjustment
made for daylight savings.  It's up to the operating system to keep
track of these settings.  This can pose some issues if multiple
operating systems are boot on the same computer using localtime as
its time format.  For instance, both operating systems might adjust
the hardware clock time for daylight savings resulting in an extra
hour of difference.<br>
<br>

The obvious solution, here, is to simply use UTC on all operating
systems and be done with it.  MacOS uses UTC, Linux uses UTC by
default, but Windows uses localtime by default.  In other words,
when booting the Linux USB off of a machine primarily used with
Windows, the chances are that the hardware clock is going to appear
to be incorrect.<br>
<br>

What this means for the Linux USB is that you may occasionally
see some time-stamp warning messages when you boot up your USB
off different machines.  We will enable a network time protocol so
that the USB Linux system will update its operating system clock
as soon as an internet connection is established and correct these
discrepancies.  More importantly, though, the Linux system will also
update the hardware clock to the correct time in UTC, meaning the
next time Windows is boot it may encounter some time-stamp errors.
In my experience, this hasn't been an issue beyond the infrequent
warning message at bootup.<br>
<br>

<h2 id="partitioning">
partitioning notes<br>
------------------</h2>

Another possibly useful option not explicitly shown
in this guide is partitioning the target USB device
to function as both a persistent bootable USB and an <a
href="https://en.wikipedia.org/wiki/NTFS" target="_blank">NTFS</a>
or <a href="https://en.wikipedia.org/wiki/File_Allocation_Table"
target="_blank">FAT32</a> formatted storage device fully compatible
as a Windows, Linux, or OSX standard USB jump drive.<br>
<br>

A final thing to point out is the lack of a
<a href="https://wiki.archlinux.org/index.php/swap"
target="_blank">swap</a> partition in this installation of Linux.
The reason for this is twofold.  First, recognizing that flash memory
has a finite number of writes before it eventually goes bad, the
lack of a swap partition may at least decrease some of those writes.
Second, realizing that nearly any computer you boot up onthese days
has at least a few gigabytes of available RAM, the need for a swap
partition is mostly non-existent.<br>
<br>

<h1 id="boot_live">
Boot Up Live Installation ISO<br>
=============================</h1>

Insert you USB or CD installation medium in the
computer and boot it up.  Use the computer's boot menu
(usually invoked with <em>[F12]</em> on a
<a href="http://www.computerhope.com/jargon/b/boot_menu.htm"
target="_blank">PC</a> or the <em>[option]</em>
key on a <a href="https://support.apple.com/en-us/HT204417"
target="_blank">Mac</a>) to select the inserted boot media.  When
presented with the boot device selection menu, select the entry for
either <em>BIOS</em> or <em>UEFI</em>
as explained <a href="#BIOS_vs_UEFI" target="_self">above</a>.<br>
<br>

A bootloader menu will appear with several options.
Select the <em>Boot Arch Linux (x86_64)</em>
or <em>(i686)</em> option as explained <a
href="#i686_vs_x86_64" target="_self">above</a>.  After  a minimal
amount of necessary drivers are loaded to RAM, you will be presented
with a root <a href="https://wiki.archlinux.org/index.php/zsh"
target="_blank">Z shell</a> prompt.<br>
<br>

<h2 id="keys_language">
keymap/language<br>
---------------</h2>

The default console keymap and
language in the live shell are, respectively, <a
href="https://en.wikipedia.org/wiki/File:KB_United_States-NoAltGr.svg"
target="blank">US</a> and US English <a
href="https://en.wikipedia.org/wiki/UTF-8" target="_blank">UTF-8</a>.
For my purposes (speaking mostly English, living mostly in Wisconsin)
this has always been exactly what I needed, and the steps below to
change these settings have never been required.<br>
<br>

If a different keyboard mapping is required, view the available
keymaps:<br>
<pre class="code-box">
+------------------------------------------------+
|# <b>ls /usr/share/kbd/keymaps/**/*.map.gz | less</b>  |
+------------------------------------------------+
</pre>
Load the required keymap.  Here, <i>mapname</i> is the
filename of the required map
without path or file extension:<br>
<pre class="code-box">
+--------------------+
|# <b>loadkeys <i>mapname</i></b>  |
+--------------------+
</pre>
<br>

To change the language of the live root environment, edit
<em>/etc/locale.gen</em> and uncomment the line
containing your desired language (for US English, uncomment
<em>en_US.UTF-8 UTF-8</em>):<br>
<pre class="code-box">
+------------------------+
|# <b>nano /etc/locale.gen</b>  |
+------------------------+
</pre>

Generate the locale information:<br>
<pre class="code-box">
+--------------+
|# <b>locale-gen</b>  |
+--------------+
</pre>
<br>

Ensure the <em>LANG</em> variable is set in
<em>/etc/locale.conf</em>
(<i>localeline</i> is the uncommented line in
<em>/etc/locale.gen</em>):<br>
<pre class="code-box">
+-------------------------------------------+
|# <b>echo LANG=<i>localeline</i> > /etc/locale.conf</b>  |
+-------------------------------------------+
</pre>
<br>

<h1 id="connect">
Connect to the Internet<br>
=======================</h1>

If there is an active networking cable plugged into the machine,
the live shell will bring up the computer's network interface card and
automatically attempt to lease an IP address from the network during
bootup.  To check the network connection, ping some website:<br>
<pre class="code-box">
+-----------------------+
|# <b>ping -c1 google.com</b>  |
+-----------------------+
</pre>
<br>

<h2 id="wired">
wired<br>
-----</h2>

If you have an active networking cable plugged into the machine
and you are unable to connect to the internet, begin troubleshooting by
viewing the interface names and statuses:<br>
<pre class="code-box">
+-----------+
|# <b>ip link</b>  |
+-----------+
</pre>
Ensure the network device is powered; <i>ethname</i>
is the name of the interface of type
<em>link/ether</em> (most likely the name is <em>eno1</em> or
<em>eno0</em>):<br>
<pre class="code-box">
+--------------------------+
|# <b>ip link set<i> ethname </i>up</b>  |
+--------------------------+
</pre>
Now attempt to manually lease a DHCP IP address from the network:<br>
<pre class="code-box">
+------------------+
|# <b>dhcpcd <i>ethname</i></b>  |
+------------------+
</pre>
If you are issued a lease, try to ping an outside server again:<br>
<pre class="code-box">
+--------------------------+
|# <b>ping -c1 archlinux.org</b>  |
+--------------------------+
</pre>
<br>

If you still aren't connected or were unable to lease an IP address,
view all the instances of dhcpcd to see what the hell is going on:<br>
<pre class="code-box">
+--------------------------------------+
|# <b>systemctl list-units | grep dhcpcd</b>  |
+--------------------------------------+
</pre>

See detailed instance information to troubleshoot any hardware
issues:<br>
<pre class="code-box">
+-------------------------------------------+
|# <b>systemctl status dhcpcd@<i>ethname</i>.service</b>  |
+-------------------------------------------+
</pre>
If you still can't connect to the internet, see the <a
href="https://wiki.archlinux.org/index.php/Network_configuration"
target="_blank">ArchWiki</a> for further help.<br>
<br>

<h2 id="wireless">
wireless<br>
--------</h2>

If a wired connection is unavailable or you prefer to use wifi, most
wireless interfaces are supported by the drivers on the installation
ISO.  To check if this is possible on your current machine, see if
any kernel drivers have been loaded for the wireless interface:<br>
<pre class="code-box">
+--------------------------------------------+
|# <b>lspci -k | grep -A3 'Network controller'</b>  |
+--------------------------------------------+
</pre>
<br>

If no device is present or no drivers have been loaded, you
are mostly out of luck; although it technically may be possible to
import the proper drivers via some other removable memory device,
such a procedure is far beyond the scope of this guide.  If you
really want to keep pursuing this route, checkout the official
Linux wireless <a href="https://wireless.wiki.kernel.org/"
target="_blank">wiki</a> and the ArchWiki wireless <a
href="https://wiki.archlinux.org/index.php/Wireless_network_configuration
#Installing_driver.2Ffirmware" target="_blank">page</a> to get
started.<br>
<br>

If the drivers have been loaded, view the names of any available
wireless interfaces:<br>
<pre class="code-box">
+----------+
|# <b>iw dev</b>  |
+----------+
</pre>
Now bring the wifi interface up (<i>wifiname</i>
is the wifi interface name given by <em>iw dev</em>:<br>
<pre class="code-box">
+---------------------------+
|# <b>ip link set <i>wifiname</i> up</b>  |
+---------------------------+
</pre>
Scan for available networks:<br>
<pre class="code-box">
+---------------------------------------+
|# <b>iw dev <i>wifiname</i> scan | grep 'SSID:'</b>  |
+---------------------------------------+
</pre>
If you don't know what type of authentication is required by the
network you want to connect to, view the full scan results:<br>
<pre class="code-box">
+-------------------------------+
|# <b>iw dev <i>wifiname</i> scan | less</b>  |
+-------------------------------+
</pre>
<br>

For a connection with no encryption:<br>
<pre class="code-box">
+-----------------------------------------+
|# <b>iw dev <i>wifiname</i> connect <i>'networkname'</i></b>  |
+-----------------------------------------+
</pre>
For a connection with <a
href="https://en.wikipedia.org/wiki/Wi-Fi_Protected_Access"
target="_blank">WPA/WPA2</a> encryption (most likely scenario):<br>
<pre class="code-box w-140 w-120 w-100 w-80">
+----------------------------------------------------------------------------+
|# <b>wpa_supplicant -i <i>wifiname</i> -c <(wpa_passphrase <i>'networkname' 'password'</i>)</b>  |
+----------------------------------------------------------------------------+
</pre>
<pre class="code-box w-60">
+-----------------------------------------------------+
|# <b>wpa_supplicant -i <i>wifiname</i> \</b>                       |
|:     <b>-c <(wpa_passphrase <i>'networkname' 'password'</i>)</b>  |
+-----------------------------------------------------+
</pre>
For a connection using <a
href="https://en.wikipedia.org/wiki/Wired_Equivalent_Privacy"
target="_blank">WEP</a> (old, not used much anymore):<br>
<pre class="code-box">
+----------------------------------------------------------+
|# <b>iw dev <i>wifiname</i> connect <i>'networkname'</i> key 0:<i>'password'</i></b>  |
+----------------------------------------------------------+
</pre>
Once a connection is established, fork the process to the background
by pressing <em>[ctrl]+z</em> and running <em>bg</em>.<br>
<br>

Finally, attempt lease an IP address:<br>
<pre class="code-box">
+-------------------+
|# <b>dhcpcd <i>wifiname</i></b>  |
+-------------------+
</pre>
Check your network connection:<br>
<pre class="code-box">
+--------------------------+
|# <b>ping -c1 archlinux.org</b>  |
+--------------------------+
</pre>
If you are
unable to obtain a wireless network connection, see the <a
href="https://wiki.archlinux.org/index.php/Wireless_network_configuration"
target="_blank">ArchWiki</a> for more information (good luck!).<br>
<br>

<h2 id="live_time">
system time<br>
-----------</h2>

Once connected to the internet, turn on the network time protocol to
synchronize system time:<br>
<pre class="code-box">
+----------------------------+
|# <b>timedatectl set-ntp true</b>  |
+----------------------------+
</pre>
<br>

<h1 id="prepare">
Prepare USB Stick<br>
=================</h1>

As mentioned earlier, this Arch Linux bootable USB stick
will be compatible with both BIOS and UEFI booting modes.
In order for a storage device to boot in BIOS mode, the
first 512 bytes of the device's memory must contain an <a
href="https://en.wikipedia.org/wiki/Master_boot_record"
target="_blank">MBR</a> (master boot record).  For a
storage device to boot in UEFI mode, a special <a
href="https://en.wikipedia.org/wiki/EFI_system_partition"
target="_blank">EFI</a> system partion is required.  Both
partitions can be created using <em>gdisk</em>.<br>
<br>

Before proceeding, determine the device name of the target USB
drive.  First, before plugging in the target USB, view the currently
available block devices:<br>
<pre class="code-box">
+---------+
|# <b>lsblk</b>  |
+---------+
</pre>
Now insert the target flash drive and view the devices again.
The newly detected device <i>/dev/sdX</i> is
the name of the target USB you will use for further partitioning and
formatting.  Note that in the device name you will use is literally
<i>/dev/sdX</i>
where the only thing that changes is the single lowercase letter value
of <i>X</i>.  Double check that you have the
correct device name <i>/dev/sdX</i>, lest you
may repartition the internal hard drive of the machine you are on!<br>
<br>

<h2 id="wipe">
wipe<br>
----</h2>

The process of zeroing out or wiping the target USB is almost
always optional, and I would suggest skipping this step the first
time through (it takes a while).  Overwriting the USB with zeros
may be needed in rare cases when previous data aligns with the newly
created partition table and is interpreted as actual files (yes, this
does happen!).  If you have trouble installing a bootloader further
on in the installation, you may have to come back to this point and
wipe your USB before continuing.<br>
<br>

Take a look at the sector size and number of sectors:<br>
<pre class="code-box">
+---------------------+
|# <b>gdisk -l <i>/dev/sdX</i></b>  |
+---------------------+
</pre>
<br>

Use dd to write the USB with all zeros, permanently erasing all
data:<br>
<pre class="code-box w-140 w-120 w-100">
+-------------------------------------------------------------------------------------------+
|# <b>dd if=/dev/zero of=<i>/dev/sdX</i> bs=<i>logical-sector-size</i> seek=0 count=<i>sectors</i> status=progress</b>  |
+-------------------------------------------------------------------------------------------+
</pre>
<pre class="code-box w-80">
+----------------------------------------------------------------------------+
|# <b>dd if=/dev/zero of=<i>/dev/sdX</i> bs=<i>logical-sector-size</i> seek=0 count=<i>sectors</i> \</b> |
|:     <b>status=progress</b>                                                       |
+----------------------------------------------------------------------------+
</pre>
<pre class="code-box w-60">
+-------------------------------------------------------+
|# <b>dd if=/dev/zero of=<i>/dev/sdX</i> bs=<i>logical-sector-size</i> \</b> |
|:     <b>seek=0 count=<i>sectors</i> status=progress</b>             |
+-------------------------------------------------------+
</pre>
Expect this to take a relatively long time (hour+) depending on
the size of the USB.<br>
<br>

<h2 id="partition">
partition<br>
---------</h2>

There are several partitioning tools available in the live
installation environment.  We'll use <em>gdisk</em>
to partition the target USB device:<br>
<pre class="code-box">
+------------------+
|# <b>gdisk <i>/dev/sdX</i></b>  |
+------------------+
</pre>
<br>

First wipe the partitions on the target USB device by typing
<em>d</em> at the interactive prompt until no partitions
remain:<br>

<pre class="code-box">
+--------------------------+
| Command (? for help): <b>d</b>  |
| No partitions            |
+--------------------------+
</pre>
<br>

Create a brand new GUID partition table:<br>
<pre class="code-box w-140 w-120 w-100 w-80">
+-----------------------------------------------------------------------+
| Command (? for help): <b>o</b>                                               |
| This option deletes all partitions and creates a new protective MBR.  |
| Proceed? (Y/N): <b>y</b>                                                     |
+-----------------------------------------------------------------------+
</pre>
<pre class="code-box w-60">
+-------------------------------------------------------+
| Command (? for help): <b>o</b>                               |
| This option deletes all partitions and creates a new  |
| protective MBR.                                       |
| Proceed? (Y/N): <b>y</b>                                     |
+-------------------------------------------------------+
</pre>
<br>

Make a 10MB MBR partition starting in the beginning of the
device's memory:<br>

<pre class="code-box w-140 w-120 w-100 w-80">
+-----------------------------------------------------------------------+
| Command (? for help): <b>n</b>                                               |
| Partition number (1-128, default 1):                                  |
| First sector (34-<em>XXXXXX</em>), default = 64) or {+-}size{KMGTP}:           |
| Last sector (64-<em>XXXXXX</em>), default = <em>XXXXXX</em>) or {+-}size{KMGTP}: <b>+10MB</b>  |
| Current type is 'Linux filesystem'                                    |
| Hex code or GUID (L to show codes, Enter = 8300): <b>EF02</b>                |
+-----------------------------------------------------------------------+
</pre>
<pre class="code-box w-60">
+---------------------------------------------------------+
| Command (? for help): <b>n</b>                                 |
| Partition number (1-128, default 1):                    |
| First sector (34-<em>XXXXXX</em>), default = 64)                 |
| or {+-}size{KMGTP}:                                     |
| Last sector (64-<em>XXXXXX</em>), default = <em>XXXXXX</em>)              |
| or {+-}size{KMGTP}: <b>+10MB</b>                               |
| Current type is 'Linux filesystem'                      |
| Hex code or GUID (L to show codes, Enter = 8300): <b>EF02</b>  |
+---------------------------------------------------------+
</pre>
<br>

Create a 500MB EFI partition:<br>
<pre class="code-box w-140 w-120 w-100 w-80">
+------------------------------------------------------------------------+
| Command (? for help): <b>n</b>                                                |
| Partition number (2-128, default 2):                                   |
| First sector (34-<em>XXXXXX</em>), default = <em>YYYY</em>) or {+-}size{KMGTP}:          |
| Last sector (64-<em>XXXXXX</em>), default = <em>XXXXXX</em>) or {+-}size{KMGTP}: <b>+500MB</b>  |
| Current type is 'Linux filesystem'                                     |
| Hex code or GUID (L to show codes, Enter = 8300): <b>EF00</b>                 |
+------------------------------------------------------------------------+
</pre>
<pre class="code-box w-60">
+---------------------------------------------------------+
| Command (? for help): <b>n</b>                                 |
| Partition number (2-128, default 2):                    |
| First sector (34-<em>XXXXXX</em>), default = <em>YYYY</em>)               |
| or {+-}size{KMGTP}:                                     |
| Last sector (64-<em>XXXXXX</em>), default = <em>XXXXXX</em>)              |
| or {+-}size{KMGTP}: <b>+500MB</b>                              |
| Current type is 'Linux filesystem'                      |
| Hex code or GUID (L to show codes, Enter = 8300): <b>EF00</b>  |
+---------------------------------------------------------+
</pre>
<br>

Finally, allocate the remaining space to the Linux partition:<br>
<pre class="code-box w-140 w-120 w-100 w-80">
+-----------------------------------------------------------------+
| Command (? for help): <b>n</b>                                         |
| Partition number (3-128, default 3):                            |
| First sector (34-<em>XXXXXX</em>), default = <em>YYYY</em>) or {+-}size{KMGTP}:   |
| Last sector (64-<em>XXXXXX</em>), default = <em>XXXXXX</em>) or {+-}size{KMGTP}:  |
| Current type is 'Linux filesystem'                              |
| Hex code or GUID (L to show codes, Enter = 8300):               |
+-----------------------------------------------------------------+
</pre>
<pre class="code-box w-60">
+----------------------------------------------------+
| Command (? for help): <b>n</b>                            |
| Partition number (3-128, default 3):               |
| First sector (34-<em>XXXXXX</em>), default = <em>YYYY</em>)          |
| or {+-}size{KMGTP}:                                |
| Last sector (64-<em>XXXXXX</em>), default = <em>XXXXXX</em>)         |
| or {+-}size{KMGTP}:                                |
| Current type is 'Linux filesystem'                 |
| Hex code or GUID (L to show codes, Enter = 8300):  |
+----------------------------------------------------+
</pre>
<br>

Double check the new partition table:<br>
<pre class="code-box">
+---------------------------+
|# Command (? for help): <b>p</b>  |
+---------------------------+
</pre>
It should look something like to this:<br>
<pre class="code-box w-140 w-120 w-100 w-80">
+----------------------------------------------------------------------------+
| Number  Start (sector)  End (sector)  Size      Code  Name                 |
|    1              64         20543   10.0 MiB   EF02  BIOS boot partition  |
|    2           20544       1044543   500.0 MiB  EF00  EFI System           |
|    3         1044544      62521310   29.3 GiB   8300  Linux filesystem     |
+----------------------------------------------------------------------------+
</pre>
<pre class="code-box w-60">
+-------------------------------------------------------+
| Number  Start       End  Size       Code  Name        |
|    1       64     20543  10.0 MiB   EF02  BIOS boot   |
|    2    20544   1044543  500.0 MiB  EF00  EFI System  |
|    3  1044544  62521310  29.3 GiB   8300  Linux       |
+-------------------------------------------------------+
</pre>
<br>

If it's all good, write it to the USB stick and exit
<em>gdisk</em>:<br>
<pre class="code-box">
+--------------------------+
| Command (? for help): <b>w</b>  |
+--------------------------+
</pre>
<br>

<h2 id="format">
format<br>
------</h2>

View the new block layout of the target USB device:<br>
<pre class="code-box">
+------------------+
|# <b>lsblk <i>/dev/sdX</i></b>  |
+------------------+
</pre>
You should now have three blocks on your target USB device: a 10MB
block <i>/dev/sdX1</i>, a 500MB block <i>/dev/sdX2</i>, and block taking all the remaining
memory<i>/dev/sdX3</i>:<br>
<pre class="code-box">
+---------------------------------------------+
| NAME   MAJ:MIN RM  SIZE RO TYPE MOUNTPOINT  |
| sd<em>X</em>      8:112  1  7.5G  0 disk             |
| ├─sd<em>X</em>1   8:113  1   10M  0 part             |
| ├─sd<em>X</em>2   8:114  1  500M  0 part             |
| └─sd<em>X</em>3   8:115  1   <em>XX</em>G  0 part</span>             |
+---------------------------------------------+
</pre>
<br>

Do not format the <i>/dev/sdX1</i> block.
This is the BIOS/MBR partion.<br>
<br>

Format the 500MB EFI system partition with a FAT32 filesystem:<br>
<pre class="code-box">
+---------------------------+
|# <b>mkfs.fat -F32 <i>/dev/sdX2</i></b>  |
+---------------------------+
</pre>
<br>

Format the Linux partition with an
<a href="https://en.wikipedia.org/wiki/Ext4" target="_blank">ext4</a>
filesystem:<br>
<pre class="code-box">
+-----------------------+
|# <b>mkfs.ext4 <i>/dev/sdX3</i></b>  |
+-----------------------+
</pre>
<br>

<h1 id="base">
Install Base Package Set<br>
========================</h1>

Following the
<a href="https://wiki.archlinux.org/index.php/Arch_Linux#Principles"
target="_blank">Arch Way</a>, this guide intends to install the
minimum number of packages necessary to create a portable working
Linux system.<br>
<br>

<h2 id="mount">
mount<br>
-----</h2>

Mount the ext4 formatted partition as the root filesystem:<br>
<pre class="code-box">
+----------------------------+
|# <b>mkdir -p /mnt/usb</b>         |
|# <b>mount <i>/dev/sdX3</i> /mnt/usb</b>  |
+----------------------------+
</pre>
Mount the FAT32 formatted EFI partition to
<em>boot</em>:<br>
<pre class="code-box">
+---------------------------------+
|# <b>mkdir /mnt/usb/boot</b>            |
|# <b>mount <i>/dev/sdX2</i> /mnt/usb/boot</b>  |
+---------------------------------+
</pre>
<br>

<h2 id="pacstrap">
pacstrap<br>
--------</h2>

Download and install the Arch Linux base packages:<br>
<pre class="code-box w-140 w-120 w-100 w-80">
+---------------------------------------------------------------+
|# <b>pacstrap /mnt/usb linux linux-firmware base base-devel nano</b>  |
+---------------------------------------------------------------+
</pre>
<pre class="code-box w-60">
+------------------------------------------------+
|# <b>pacstrap /mnt/usb linux linux-firmware base \</b> |
|:     <b>base-devel nano</b>                           |
+------------------------------------------------+
</pre>
<br>

<h2 id="fstab">
fstab<br>
-----</h2>

The <a href="https://en.wikipedia.org/wiki/Fstab"
target="_blank">fstab</a> is used by Linux systems to correctly
mount available disk partitions on bootup.  The partitions
can be identified in the <em>fstab</em> in
several ways, and some install methods still use the standard
labels (<em>/dev/...</em>) instead of <a
href="https://en.wikipedia.org/wiki/Universally_unique_identifier"
target="_blank">UUIDs</a>.  This would surely be a failure point of an
install on a USB stick as the standard assigned labels for removable
devices are not consistent on each boot.<br>
<br>

Toggle the <em>-U</em> tag to enable UUIDs as
<em>fstab</em> source identifiers:<br>
<pre class="code-box">
+---------------------------------------------+
|# <b>genfstab -U /mnt/usb > /mnt/usb/etc/fstab</b>  |
+---------------------------------------------+
</pre>
<br>

Check <em>/etc/fstab</em>, in an editor:<br>
<pre class="code-box">
+---------------------------+
|# <b>nano /mnt/usb/etc/fstab</b>  |
+---------------------------+
</pre>
You may need to manually remove entries from your host system.
For additional help manually editing
<em>/etc/fstab</em>, see the
<a href="https://wiki.archlinux.org/index.php/Fstab"
target="_blank">wiki</a>.<br>
<br>


<h1 id="configure">
Configure New System<br>
====================</h1>

Your USB stick should now contain a persistent Linux system.
We still need to configure a few things before it's ready to boot on
its own, though.<br>
<br>

In addition to the base packages and in the name of ultimate
portability, we will also pull and install the required programs
to support automatic wired networking, manual wireless networking,
all common graphics cards, touchpad input devices, and laptop battery
systems.  We also need to make some configuration tweaks to ensure that
the new system loads support for removable devices before it attempts
to access the filesystems, and that it assigns consistent names to
network devices regardless of the machine it is boot up on.<br>
<br>

<h2 id="chroot">
chroot<br>
------</h2>

Begin by <a href="https://wiki.archlinux.org/index.php/change_root"
target="_blank">chrooting</a> into the new system.  Besides the
final network settings, everything can be set within the
<em>chroot</em> environment:<br>
<pre class="code-box">
+------------------------+
|# <b>arch-chroot /mnt/usb</b>  |
+------------------------+
</pre>
<br>

<h2 id="locale">
locale<br>
------</h2>


Use <a href="http://www.tldp.org/LDP/abs/html/tabexpansion.html"
target="_blank">tab-completion</a> to discover your appropriate
entries for your <i>region</i> and <i>city</i>:<br>
<pre class="code-box">
+---------------------------------------------------------+
|# <b>ln -sf /usr/share/zoneinfo/<i>region</i>/<i>city</i> /etc/localtime</b>  |
+---------------------------------------------------------+
</pre>
Generate <em>/etc/adjtime</em>:<br>
<pre class="code-box">
+---------------------+
|# <b>hwclock --systohc</b>  |
+---------------------+
</pre>
<br>

Edit <em>/etc/locale.gen</em> and uncomment your
desired language:<br>
<pre class="code-box">
+------------------------+
|# <b>nano /etc/locale.gen</b>  |
+------------------------+
</pre>
(for US English, uncomment <em>en_US.UTF-8UTF-8</em>)<br>
<br>

Generate the locale information:<br>
<pre class="code-box">
+--------------+
|# <b>locale-gen</b>  |
+--------------+
</pre>
Set the <em>LANG</em> variable
in <em>/etc/locale.conf</em>:<br>
<pre class="code-box">
+-------------------------------------------+
|# <b>echo LANG=<i>localeline</i> > /etc/locale.conf</b>  |
+-------------------------------------------+
</pre>
(for US English, <i>localeline</i> is
<em>en_US.UTF-8</em>)<br>
<br>

<h2 id="hostname">
hostname<br>
--------</h2>

Create the <em>/etc/hostname</em> file containing
your desired <a href="https://en.wikipedia.org/wiki/Hostname"
target="_blank">valid</a> <i>hostname</i> on a
single line:<br>
<pre class="code-box">
+---------------------------------+
|# <b>echo <i>hostname</i> > /etc/hostname</b>  |
+---------------------------------+
</pre>
<br>

Open <em>/etc/hosts</em> in an editor:<br>
<pre class="code-box">
+-------------------+
|# <b>nano /etc/hosts</b>  |
+-------------------+
</pre>
Add the lines:<br>
<pre class="code-box">
+------------------------------------------------+
| <b>127.0.0.1    localhost</b>                         |
| <b>::1          localhost</b>                         |
| <b>127.0.1.1    <i>hostname</i>.localdomain    <i>hostname</i></b>  |
+------------------------------------------------+
</pre>
<br>

<h2 id="RAM_disk">
RAM disk image<br>
--------------</h2>

In order to boot the Linux Kernel persistently off of a
USB device, some adjustments may be necessary to the initial
<a href="https://en.wikipedia.org/wiki/Initrd" target="_blank">RAM disk
image</a>.  We need to ensure that block device support is properly
loaded before any attempt at loading the filesystem.  This not always
the way a RAM disk image is configured in a generic Linux installation,
and I suspect this may one of the failure points in other
Linux USB installations out there.  To configure a custom RAM disk
image, open <em>/etc/mkinitcpio.conf</em> in
an editor:<br>
<pre class="code-box">
+-----------------------------+
|# <b>nano /etc/mkinitcpio.conf</b>  |
+-----------------------------+
</pre>
Ensure the <em>block</em> hook comes before the
<em>filesystems</em> hook and directly after the
<em>udev</em> hook like the following:<br>
<pre class="code-box">
+----------------------------------------------------+
| HOOKS=(base udev block filesystems keyboard fsck)  |
+----------------------------------------------------+
</pre>
<br>

Now regenerate the initial RAM disk image with the changes made:<br>
<pre class="code-box">
+-----------------------+
|# <b>mkinitcpio -p linux</b>  |
+-----------------------+
</pre>
<br>

<h2 id="interface_names">
network interface names<br>
-----------------------</h2>

Arch Linux's basic service manager,
<a href="https://wiki.archlinux.org/index.php/Systemd"
target="_blank">systemd</a>, assigns network interfaces <a
href="http://tinyurl.com/j8xesvh" target="_blank">predictable
names</a> based on the actual device hardware.  This is great for
just about any other type of install, but can pose some problems
for the portable USB installation we're going for.  To ensure that
the ethernet and wifi interfaces will always be respectively named
<em>eth0</em> and <em>wlan0</em>,
revert the Arch Linux USB back to traditional device naming:<br>
<pre class="code-box w-140 w-120 w-100 w-80">
+-------------------------------------------------------------+
|# <b>ln -s /dev/null /etc/udev/rules.d/80-net-setup-link.rules</b>  |
+-------------------------------------------------------------+
</pre>
<pre class="code-box w-60">
+-------------------------------------------------+
|# <b>ln -s /dev/null \</b>                              |
|:     <b>/etc/udev/rules.d/80-net-setup-link.rules</b>  |
+-------------------------------------------------+
</pre>
<br>

<h2 id="journal_config">
journal config<br>
--------------</h2>

A default installation of Arch Linux is setup with
<a href="https://wiki.archlinux.org/index.php/Systemd"
target="_blank">systemd</a> to continuously journal various
information about current processes and write that data to
storage on disk.  For a persistent bootable installation on a
flash memory device, however, we can change some options in <a
href="http://tinyurl.com/jhmtjay" target="_blank">journald.conf</a>
to enable journal keeping entirely in RAM (thus reducing writes to
the flash device).  To control where journal data is stored, open
<em>/etc/systemd/journald.conf</em> in and editor:<br>
<pre class="code-box">
+-----------------------------------+
|# <b>nano /etc/systemd/journald.conf</b>  |
+-----------------------------------+
</pre>
To switch journal data storage to RAM, set the storage variable to
volatile by ensuring the following line is uncommented:<br>
<pre class="code-box">
+-------------------+
| Storage=volatile  |
+-------------------+
</pre>
As an additional precaution, to ensure the operating system doesn't
overfill RAM with journal data, set the max-use variable by adding the
line:<br>
<pre class="code-box">
+-------------------+
| SystemMaxUse=16M  |
+-------------------+
</pre>
<br>

<h2 id="mount_options">
mount options<br>
-------------</h2>

Modern filesystems are able to record various metadata (last
accessed, last modified, user rights, etc.) about their files.
A default filesystem mount generally keeps track of as much as this
information as possible.  For a persistent bootable operating system
on a flash memory device, however, we should limit some of this record
keeping in order to reduce writes to the flash device.  Using the
<a href="http://tinyurl.com/55so5r" target="_blank">noatime</a>
mount option in <a href="https://wiki.archlinux.org/index.php/Fstab"
target="_blank">fstab</a>  will disable the record keeping of file
access times: no writes will occur when a file is read, only when it
is modified.<br>
<br>

To disable record keeping of file access times for the bootable USB,
open <em>/etc/fstab</em> in an editor:<br>
<pre class="code-box">
+-------------------+
|# <b>nano /etc/fstab</b>  |
+-------------------+
</pre>
Change the mount options from <em>relatime</em>
to <em>noatime</em>.<br>
<br>

<h2 id="bootloader">
bootloader<br>
----------</h2>

To enable booting the target USB stick in both boot modes, two
<a href="https://wiki.archlinux.org/index.php/Category:Boot_loaders"
target="_blank">bootloaders</a> will need to be
installed.  For ease of installation, we'll install
<a href="https://en.wikipedia.org/wiki/GNU_GRUB" target="_blank">GRUB</a>
for both modes.<br>
<br>

Install the <em>grub</em> and <em>efibootmgr</em> packages:<br>
<pre class="code-box">
+-----------------------------+
|# <b>pacman -S grub efibootmgr</b>  |
+-----------------------------+
</pre>
View the current block devices to determine the target USB
device:<br>
<pre class="code-box">
+---------+
|# <b>lsblk</b>  |
+---------+
</pre>
Note the target USB device name (without any numbers)
<i>/dev/sdX</i>.<br>
<br>

Setup GRUB for MBR/BIOS booting mode:<br>
<pre class="code-box w-140 w-120 w-100">
+-----------------------------------------------------------------------------+
|# <b>grub-install --target=i386-pc --boot-directory /boot --removable <i>/dev/sdX</i></b>  |
+-----------------------------------------------------------------------------+
</pre>
<pre class="code-box w-80 w-60">
+---------------------------------------------------------+
|# <b>grub-install --target=i386-pc --boot-directory /boot \</b> |
|:    <b>--removable <i>/dev/sdX</i></b>                                |
+---------------------------------------------------------+
</pre>
Setup GRUB for UEFI booting mode:<br>
<pre class="code-box w-140 w-120 w-100">
+---------------------------------------------------------------------------------------------+
|# <b>grub-install --target=x86_64-efi --efi-directory /boot --boot-directory /boot --removable</b>  |
+---------------------------------------------------------------------------------------------+
</pre>
<pre class="code-box w-80">
+-----------------------------------------------------------+
|# <b>grub-install --target=x86_64-efi --efi-directory /boot \</b> |
|:     <b>--boot-directory /boot --removable</b>                   |
+-----------------------------------------------------------+
</pre>
<pre class="code-box w-60">
+-----------------------------------------------------+
|# <b>grub-install --target=x86_64-efi --efi-directory \</b> |
|:     <b>/boot --boot-directory /boot --removable</b>       |
+-----------------------------------------------------+
</pre>
<br>

Generate a GRUB configuration:<br>
<pre class="code-box">
+----------------------------------------+
|# <b>grub-mkconfig -o /boot/grub/grub.cfg</b>  |
+----------------------------------------+
</pre>
<br>

<h2 id="networking">
networking<br>
----------</h2>

Install the <em>ifplugd</em> package to configure
automatic IP leasing on ethernet devices:<br>
<pre class="code-box">
+----------------------------+
|# <b>pacman -S netctl ifplugd</b>  |
+----------------------------+
</pre>
Install the packages to enable wifi support with a basic command
line interface:<br>
<pre class="code-box">
+--------------------------------------+
|# <b>pacman -S iw wpa_supplicant dialog</b>  |
+--------------------------------------+
</pre>
<br>

Copy the example ethernet profile to
<em>/etc/netctl/</em>:<br>
<pre class="code-box w-140 w-120 w-100 w-80">
+---------------------------------------------------------------+
|# <b>cp /etc/netctl/examples/ethernet-dhcp /etc/netctl/eth0-dhcp</b>  |
+---------------------------------------------------------------+
</pre>
<pre class="code-box w-60">
+------------------------------------------+
|# <b>cp /etc/netctl/examples/ethernet-dhcp \</b> |
|:     <b>/etc/netctl/eth0-dhcp</b>           |
+------------------------------------------+
</pre>
Enable <em>ifplugd</em> to automatically connect to
any available wired network:<br>
<pre class="code-box">
+------------------------------------------------+
|# <b>systemctl enable netctl-ifplugd@eth0.service</b>  |
+------------------------------------------------+
</pre>
Enable network time synchronization:<br>
<pre class="code-box">
+----------------------------------------------+
|# <b>systemctl enable systemd-timesyncd.service</b>  |
+----------------------------------------------+
</pre>
<br>

<h2 id="video">
video drivers<br>
-------------</h2>

To support most common GPUs, install all five basic open source
video drivers:<br>

<pre class="code-box w-140 w-120 w-100">
+--------------------------------------------------------------------------------------------------+
|# <b>pacman -S xf86-video-amdgpu xf86-video-ati xf86-video-intel xf86-video-nouveau xf86-video-vesa</b>  |
+--------------------------------------------------------------------------------------------------+
</pre>
<pre class="code-box w-80">
+----------------------------------------------------------------+
|# <b>pacman -S xf86-video-amdgpu xf86-video-ati xf86-video-intel \</b> |
|:    <b>xf86-video-nouveau xf86-video-vesa</b>                         |
+----------------------------------------------------------------+
</pre>
<pre class="code-box w-60">
+----------------------------------------------------------+
|# <b>pacman -S xf86-video-amdgpu xf86-video-ati \</b>            |
|:    <b>xf86-video-intel xf86-video-nouveau xf86-video-vesa</b>  |
+----------------------------------------------------------+
</pre>
<br>

<h2 id="touchpad">
touchpad support<br>
----------------</h2>

Install support for standard notebook touchpads:<br>
<pre class="code-box">
+----------------------------------+
|# <b>pacman -S xf86-input-synaptics</b>  |
+----------------------------------+
</pre>
<br>

<h2 id="battery">
battery support<br>
---------------</h2>

Install support for checking battery charge and state:<br>
<pre class="code-box">
+------------------+
|# <b>pacman -S acpi</b>  |
+------------------+
</pre>
<br>

<h2 id="root">
root password<br>
-------------</h2>

Set the root password:<br>
<pre class="code-box">
+----------+
|# <b>passwd</b>  |
+----------+
</pre>
<br>

<h2 id="user">
user account<br>
------------</h2>

Create a new user <i>user</i>:<br>
<pre class="code-box">
+-------------------+
|# <b>useradd -m <i>user</i></b>  |
+-------------------+
</pre>
Set <i>user</i> password:<br>
<pre class="code-box">
+---------------+
|# <b>passwd <i>user</i></b>  |
+---------------+
</pre>
<br>

Linux isn't meant to be used with root-user privileges all the
time.  Enable <a href="https://wiki.archlinux.org/index.php/sudo"
target="_blank">sudo</a> for <i>user</i>
by creating a rule in <em>/etc/sudoers.d/</em>:<br>
<pre class="code-box">
+------------------------------------------------------+
|# <b>echo '<i>user</i> ALL=(ALL) ALL' > /etc/sudoers.d/10-<i>user</i></b>  |
+------------------------------------------------------+
</pre>
<br>

Optionally, install
<a href="https://wiki.archlinux.org/index.php/Polkit"
target="_blank">polkit</a> to ease privilege escalation for
various system tasks:<br>
<pre class="code-box">
+--------------------+
|# <b>pacman -S polkit</b>  |
+--------------------+
</pre>
<br>

<h2 id="logout">
logout<br>
------</h2>

Logout of the chroot:<br>
<pre class="code-box">
+----------+
|# <b>logout</b>  |
+----------+
</pre>
Unmount the USB:<br>
<pre class="code-box">
+-----------------------------------------+
|# <b>umount /mnt/usb/boot /mnt/usb &amp;&amp; sync</b>  |
+-----------------------------------------+
</pre>
<br>

<h1 id="complete">
Installation Complete!<br>
======================</h1>

Welcome to Arch Linux!  First
time users should probably checkout the ArchWiki's
<a href="https://wiki.archlinux.org/index.php/general_recommendations"
target="_blank">general recommendations</a>.
<br>
<br>
Be safe, have fun, and treat each other nice... out...<br>

</body>
</html>
